#' Extract features from Antismash json files
#'
#' @param jsons A character vector of valid filepaths.
#' @param features_types A list of desired features types, by default all.
#'
#' @return A list of list of records.
#' @export
#'
get_antismash_features <- function(jsons, features_types=NULL){
  fn <- purrr::possibly(get_features_list_,quiet = FALSE)
  purrr::map(jsons, fn,feature_types = features_types)
}

get_features_list_ <- function(json, feature_types = NULL){
  filter_fn <- function(x) {
    if (is.null(feature_types)){return(TRUE)}
    x$type %in% feature_types
  }
  records <- json |>
    jsonlite::read_json()|>
    purrr::pluck("records")
  contig_accessions <- records |>
    purrr::map(purrr::pluck, "annotations", "accessions",1, .default = "") |>
    as.character() |>
    make.unique()
  names(records) <- contig_accessions
  records |>
    purrr::map(purrr::pluck, "features") |>
    purrr::map(~purrr::keep(., filter_fn)) |>
    purrr::compact()
}

extract_from <- function(x, ...) {
  x |>
    purrr::list_flatten()|>
    purrr::map(purrr::pluck, ..., .default = NA)
}

#' Creates a dataframe with region information from antiSMASH data
#' @param features List object generated by `get_antismash_features`
#' @return A tibble where each where each region is an observation
#' @export
get_antismash_regions <- function(features){
  fn <- purrr::possibly(get_antismash_regions_,quiet = FALSE)
  purrr::map(features, fn) |>
    dplyr::bind_rows(.id = "file")
  }

get_antismash_regions_ <- function(features){
  filter_fn <- function(x) x$type == "region"
  regions <- features |>
    purrr::map(~purrr::keep(., filter_fn))
  if (length(regions)== 0) {return(NULL)}

  region_numbers <- extract_from(
    regions, "qualifiers", "region_number"
  ) |> purrr::list_flatten() |>as.numeric()

  tibble::tibble(
    location = extract_from(regions, "location") |> as.character(),
    type = extract_from(regions, "type") |> as.character(),
    contig_edge = extract_from(
      regions, "qualifiers", "contig_edge"
      ) |> purrr::list_flatten() |> as.logical(),
    product = extract_from(
      regions, "qualifiers", "product"
    ) |> purrr::map(purrr::compose(sort, as.character)) |> as.list(),
    contig = names(regions)
  ) |>
    dplyr::mutate(
      bgc_id = paste0(contig, ".region", stringr::str_pad(
        region_numbers, width = 3, pad = '0'))
    )
}


#' Creates a dataframe with module information from antiSMASH data
#' @param features List object generated by `get_antismash_features`
#' @return A tibble where each where each region is an observation
#' @export
get_antismash_modules <- function(features){
  fn <- purrr::possibly(get_antismash_modules_,quiet = FALSE)
  purrr::map(features, fn) |>
    dplyr::bind_rows(.id = "file")
}



get_antismash_modules_ <- function(features){
  filter_fn <- function(x) x$type == "aSModule"
  modules <- features |>
    purrr::map(~purrr::keep(., filter_fn))
  qualifiers <- extract_from(modules, "qualifiers")
  tibble::tibble(
    location = extract_from(modules, "location") |>
      as.character(),
    complete = purrr::map(qualifiers, ~ 'complete' %in% names(.)) |>
      as.logical(),
    type = extract_from(modules, "qualifiers", "type") |>
      purrr::list_flatten() |> as.character(),
    iterative = purrr::map(qualifiers, ~ 'iterative' %in% names(.)) |>
      as.logical(),
    contig = names(modules)
  )
}
